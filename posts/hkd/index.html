<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Higher-kinded data in Scala 3 | charlibot</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://charlibot.github.io/css/main.min.ce23eec8f640381388384c91e14580151e1fbd865e5782e2913fe7a1d8c18c59.css><link type=text/css rel=stylesheet href=/css/custom.css></head><body><nav><header><div class=site-title><a href=/>charlibot</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/about/>About</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=/archives/>Archives</a>
<a class="color-link nav-link" href=https://charlibot.github.io/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons><a class=social-icon href=https://github.com/charlibot target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://charlibot.github.io/js/main.min.c1aee25a817e9beb1f9c4afd9d62311227a7f5e46720e404dc1dda97281f47f2.js integrity="sha256-wa7iWoF+m+sfnEr9nWIxEien9eRnIOQE3B3alygfR/I=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Higher-kinded data in Scala 3</h1><time>May 7, 2021</time><div><p><p>Higher-kinded data (HKD) takes your existing data classes and wraps each field in a higher-kinded type, allowing you to do some funky things. I have recently seen a few presentations of this which piqued my interest sufficiently to try it out for myself. Given Scala 3 is just around the corner, I will use this as a chance to also try that out.</p><p>I will link the talks, along with source code and blogs I found along the way, at the end. They are great resources to go deeper than I will do here.</p><h2 id=terminology>Terminology</h2><p>To get started, let&rsquo;s break down some of the terms in that first sentence. A data class in Scala is best represented with a case class. Let&rsquo;s say a person with a name, age, postcode and possibly a nickname:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>case</span> <span class=k>class</span> <span class=nc>Person</span><span class=o>(</span>
    <span class=n>name</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> 
    <span class=n>age</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span> 
    <span class=n>postcode</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> 
    <span class=n>nickname</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span>
<span class=o>)</span>
</code></pre></div><p>I find higher-kinded types easiest to understand with an example. They are usually used in the contexts of type classes. A functor is the most recognisable example:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span><span class=nc>:</span>
  <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span>
</code></pre></div><p><code>F[_]</code> here is a higher-kinded type because it takes another type to return a proper type. Given this, we can implement <code>Functor</code> for many concrete data types that fit, such as <code>Option</code>, <code>List</code> and <code>IO</code>. For example, we can write the Option instance as:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>given</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>Option</span><span class=o>]</span> <span class=k>with</span> 
  <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>A</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=</span>
    <span class=n>fa</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>f</span><span class=o>)</span> 
</code></pre></div><p>This delegates to the underlying <code>Option</code>&rsquo;s <code>map</code> method which performs the function <code>f</code> if the value is present, otherwise it does nothing.</p><p>Now we can look at the motivation for HKD.</p><h2 id=motivation>Motivation</h2><p>Say we had an API to add a person using the case class above which does some IO in doing so (e.g. inserting to a database):</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>addPerson</span><span class=o>(</span><span class=n>person</span><span class=k>:</span> <span class=kt>Person</span><span class=o>)</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>PersonId</span><span class=o>]</span>
</code></pre></div><p>Now we need to add another API to update this person. However, not all the fields would be updated. We could use a <code>Map[String, Any]</code> in our update function but that is not ideal. We could pass a <code>Person</code> instance with <code>null</code> or values representing no update for fields we do not want to be part of the update call but, again, this is not great.</p><p>A nicer solution is to create a person where each field is optional:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>case</span> <span class=k>class</span> <span class=nc>MaybePerson</span><span class=o>(</span>
    <span class=n>name</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>age</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Int</span><span class=o>],</span> 
    <span class=n>postcode</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>nickname</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span>
<span class=o>)</span>
</code></pre></div><p>Now we would have</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>updatePerson</span><span class=o>(</span><span class=n>id</span><span class=k>:</span> <span class=kt>PersonId</span><span class=o>,</span> <span class=n>person</span><span class=k>:</span> <span class=kt>MaybePerson</span><span class=o>)</span><span class=k>:</span> <span class=kt>IO</span><span class=o>[</span><span class=kt>Unit</span><span class=o>]</span>
</code></pre></div><p>An improvement over using <code>null</code>s or <code>Map[String, Any]</code> but now we have a class almost identical to <code>Person</code> that needs to be kept in sync if any fields are updated, removed or added.</p><p>Next, we are asked to provide an API that can stream revisions for each field. Let&rsquo;s try to define a streaming case class:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>case</span> <span class=k>class</span> <span class=nc>StreamingPerson</span><span class=o>(</span>
    <span class=n>name</span><span class=k>:</span> <span class=kt>Stream</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>age</span><span class=k>:</span> <span class=kt>Stream</span><span class=o>[</span><span class=kt>Int</span><span class=o>],</span> 
    <span class=n>postcode</span><span class=k>:</span> <span class=kt>Stream</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>nickname</span><span class=k>:</span> <span class=kt>Stream</span><span class=o>[</span><span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span>
<span class=o>)</span>
</code></pre></div><p>Our ScalaJS page that display a list of people will now be able to update each person&rsquo;s field in real-time by subscribing to each of these streams.</p><p>At this point we can see a pattern. The <code>MaybePerson</code> and <code>StreamingPerson</code> case classes use the same fields and underlying types as the <code>Person</code> class but with a different wrapper in each case.</p><p>Using higher-kinded types, we can reduce this boilerplate substantially:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>case</span> <span class=k>class</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span>
    <span class=n>name</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>age</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Int</span><span class=o>],</span> 
    <span class=n>postcode</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>nickname</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span>
<span class=o>)</span>

<span class=k>type</span> <span class=kt>Identity</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=k>=</span> <span class=n>A</span>
<span class=k>type</span> <span class=kt>Person</span> <span class=o>=</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>Identity</span><span class=o>]</span>
<span class=k>type</span> <span class=kt>MaybePerson</span> <span class=o>=</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>Option</span><span class=o>]</span>
<span class=k>type</span> <span class=kt>StreamingPerson</span> <span class=o>=</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>Stream</span><span class=o>]</span>
</code></pre></div><p>Anytime we add a new field to PersonF, we need not touch the other types. Our work will focus on implementing the update call for that field or streaming the other field or whatever it may be.</p><h2 id=validation>Validation</h2><p>Focusing on the <code>addPerson</code> and <code>updatePerson</code> functions from before, it might be best to validate the values passed to these functions before committing the changes to the database. Furthermore, if those API requests originate from some user-facing UI, getting back an error message alongside each field would be helpful.</p><p>Ordinarily, we would write a function <code>validatePerson</code> which then might call <code>validateName</code>, <code>validateAge</code>, <code>validatePostcode</code> and <code>validateNickname</code>. We quickly run into the same problem as before where new fields means more validations that might fall out of sync with the underlying data class.</p><p>Let&rsquo;s define two new type aliases that can help us out:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>type</span> <span class=kt>Validation</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=</span> <span class=n>T</span> <span class=k>=&gt;</span> <span class=nc>Either</span><span class=o>[</span><span class=kt>String</span>, <span class=kt>T</span><span class=o>]</span>
<span class=k>type</span> <span class=kt>ValidatedPerson</span> <span class=o>=</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>Validation</span><span class=o>]</span>
</code></pre></div><p>What we are saying here is each field of <code>ValidatedPerson</code> will be a function that returns either the value passed into it or an error message. Let&rsquo;s take a look at an example with some silly validations:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>val</span> <span class=n>personValidations</span> <span class=k>=</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>Validation</span><span class=o>](</span>
    <span class=n>name</span> <span class=k>=&gt;</span> <span class=nc>Either</span><span class=o>.</span><span class=n>cond</span><span class=o>(</span><span class=n>name</span><span class=o>.</span><span class=n>startsWith</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>),</span> <span class=n>name</span><span class=o>,</span> <span class=s>&#34;Name does not begin with &#39;C&#39;&#34;</span><span class=o>),</span>
    <span class=n>age</span> <span class=k>=&gt;</span> <span class=nc>Either</span><span class=o>.</span><span class=n>cond</span><span class=o>(</span><span class=n>age</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>,</span> <span class=n>age</span><span class=o>,</span> <span class=s>&#34;Age must be greater than 0&#34;</span><span class=o>),</span>
    <span class=n>postcode</span> <span class=k>=&gt;</span> <span class=nc>Either</span><span class=o>.</span><span class=n>cond</span><span class=o>(</span><span class=n>postcode</span><span class=o>.</span><span class=n>matches</span><span class=o>(</span><span class=n>postcodeRegex</span><span class=o>),</span> <span class=n>postcode</span><span class=o>,</span> <span class=s>&#34;Postcode doesn&#39;t look right&#34;</span><span class=o>),</span>
    <span class=n>nickname</span> <span class=k>=&gt;</span> <span class=nc>Right</span><span class=o>(</span><span class=n>nickname</span><span class=o>)</span>
<span class=o>)</span>
</code></pre></div><p>How do we apply these validations to an instance of <code>Person</code> or <code>MaybePerson</code>? The operative word being &ldquo;apply&rdquo;, which we will explore more later. We previously introduced <code>Functor</code> without much ceremony. This is a type class that injects a function into a data type. We also provided an instance of <code>Functor</code> for <code>Option</code>. Let&rsquo;s rework that a little to make use of Scala 3&rsquo;s extension methods and add a <code>Functor</code> instance for <code>Identity</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span><span class=nc>:</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span> 
    <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span>

<span class=n>given</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>Identity</span><span class=o>]</span> <span class=k>with</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Identity</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span> 
    <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>Identity</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>f</span><span class=o>(</span><span class=n>fa</span><span class=o>)</span> 

<span class=n>given</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>Option</span><span class=o>]</span> <span class=k>with</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>fa</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>f</span><span class=o>)</span> 
</code></pre></div><p>Now we can write a function that relies on the the Functor capability that <code>Option</code> and <code>Identity</code> has to give us a validated person:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>type</span> <span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=k>=</span> <span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=o>=&gt;&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>Either</span><span class=o>[</span><span class=kt>String</span>, <span class=kt>A</span><span class=o>]]</span>
<span class=k>def</span> <span class=n>validatePersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Functor</span><span class=o>](</span><span class=n>personF</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span> 
  <span class=nc>PersonF</span><span class=o>(</span>
    <span class=n>personF</span><span class=o>.</span><span class=n>name</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>personValidations</span><span class=o>.</span><span class=n>name</span><span class=o>),</span>
    <span class=n>personF</span><span class=o>.</span><span class=n>age</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>personValidations</span><span class=o>.</span><span class=n>age</span><span class=o>),</span>
    <span class=n>personF</span><span class=o>.</span><span class=n>postcode</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>personValidations</span><span class=o>.</span><span class=n>postcode</span><span class=o>),</span>
    <span class=n>personF</span><span class=o>.</span><span class=n>nickname</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>personValidations</span><span class=o>.</span><span class=n>nickname</span><span class=o>)</span>
  <span class=o>)</span>
</code></pre></div><p>And if we wanted to return whether the validation completed as a whole where we fail with the validated person if at least one of the validations did not pass or returning the person otherwise:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>validatePersonFComplete</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Traverse</span><span class=o>](</span><span class=n>personF</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span>, <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span> 
  <span class=k>val</span> <span class=n>v</span> <span class=k>=</span> <span class=n>validatePersonF</span><span class=o>(</span><span class=n>personF</span><span class=o>)</span>
  <span class=k>val</span> <span class=n>p</span> <span class=k>=</span> <span class=k>for</span> 
    <span class=n>name</span> <span class=k>&lt;-</span> <span class=n>v</span><span class=o>.</span><span class=n>name</span><span class=o>.</span><span class=n>sequence</span>
    <span class=n>age</span> <span class=k>&lt;-</span> <span class=n>v</span><span class=o>.</span><span class=n>age</span><span class=o>.</span><span class=n>sequence</span>
    <span class=n>postcode</span> <span class=k>&lt;-</span> <span class=n>v</span><span class=o>.</span><span class=n>postcode</span><span class=o>.</span><span class=n>sequence</span>
    <span class=n>nickname</span> <span class=k>&lt;-</span> <span class=n>v</span><span class=o>.</span><span class=n>nickname</span><span class=o>.</span><span class=n>sequence</span>
  <span class=k>yield</span> <span class=nc>PersonF</span><span class=o>(</span><span class=n>name</span><span class=o>,</span> <span class=n>age</span><span class=o>,</span> <span class=n>postcode</span><span class=o>,</span> <span class=n>nickname</span><span class=o>)</span>
  <span class=n>p</span><span class=o>.</span><span class=n>fold</span><span class=o>(</span><span class=k>_</span> <span class=k>=&gt;</span> <span class=nc>Left</span><span class=o>(</span><span class=n>v</span><span class=o>),</span> <span class=nc>Right</span><span class=o>(</span><span class=k>_</span><span class=o>))</span>
</code></pre></div><p>There&rsquo;s a bit to unpack here before moving on. If you&rsquo;re already familiar with <code>Traverse</code> and what those <code>.sequence</code> calls are doing, feel free to skip ahead to the next section, otherwise, let&rsquo;s dive in.</p><p>Our <code>v.age</code> from the snippet above is of type <code>F[Either[String, Int]]</code>, however we want to get the <code>Either</code> on the outside. That&rsquo;s where <code>.sequence</code> comes in, this essentially turns the types inside out, moving the <code>F</code> inside so we end up with <code>Either[String, F[Int]]</code>. The for comprehension helps us then construct our person on the right side if everything went well.</p><p>To be able to call <code>.sequence</code>, the <code>F</code> needs to be traversable, hence the type class <code>Traverse</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>Traverse</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=nc>extends</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>F</span><span class=o>]</span><span class=k>:</span>
  <span class=kt>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>traverse</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>B</span><span class=o>])</span><span class=k>:</span> <span class=kt>G</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]]</span>
    <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=</span> <span class=n>fa</span><span class=o>.</span><span class=n>traverse</span><span class=o>[</span><span class=kt>Identity</span>, <span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=o>)</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>A</span><span class=o>](</span><span class=n>fga</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>A</span><span class=o>]])</span>
    <span class=k>def</span> <span class=n>sequence</span><span class=k>:</span> <span class=kt>G</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>]]</span> <span class=k>=</span> <span class=n>fga</span><span class=o>.</span><span class=n>traverse</span><span class=o>(</span><span class=n>ga</span> <span class=k>=&gt;</span> <span class=n>ga</span><span class=o>)</span>
</code></pre></div><p>In fact, <code>sequence</code> is written in terms of <code>traverse</code> which is a more generic function so let&rsquo;s focus on that. It is often used to perform some effect, for example taking a name and looking up an ID in a database, <code>String => IO[Int]</code>, on a <code>List</code> of items, names in this case, returning the list within a single effect, <code>IO[List[Int]]</code> instead of <code>List[IO[Int]]</code>. However, this ability to switch the place of the effect can be helpful in other places like ours.</p><p>Looking at the signature a little closer, we see <code>G</code> is required to have an instance of the <code>Applicative</code> type class:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>Applicative</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=nc>extends</span> <span class=nc>Functor</span><span class=o>[</span><span class=kt>F</span><span class=o>]</span><span class=k>:</span>
  <span class=kt>def</span> <span class=kt>pure</span><span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>x</span><span class=k>:</span> <span class=kt>A</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>ap</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>ff</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span> <span class=k>=&gt;</span> <span class=kt>B</span><span class=o>])</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span>
    <span class=k>def</span> <span class=n>map</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>fa</span><span class=o>.</span><span class=n>ap</span><span class=o>(</span><span class=n>pure</span><span class=o>(</span><span class=n>f</span><span class=o>))</span>
    <span class=k>def</span> <span class=n>map2</span><span class=o>[</span><span class=kt>B</span>, <span class=kt>C</span><span class=o>](</span><span class=n>fb</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=o>(</span><span class=kt>A</span><span class=o>,</span> <span class=kt>B</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>C</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>C</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>fb</span><span class=o>.</span><span class=n>ap</span><span class=o>(</span><span class=n>fa</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>a</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>b</span><span class=k>:</span> <span class=kt>B</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)))</span>
</code></pre></div><p><code>Applicative</code> gives us the ability to lift an object into the <code>F</code> type with <code>pure</code>. It also gives us the ability to take two <code>F</code> objects and apply a function on both of their internal values together, producing a new <code>F</code> with <code>map2</code>. Note that <code>map2</code> is written in terms of <code>ap</code> which I find to be less intuitive than <code>map2</code> so will forego explanation.</p><p>Mapping these type classes back to our validation function, we need our <code>F[_]</code> to have <code>Traverse</code> instances and <code>Either[String, _]</code> needs to be applicative. On the latter:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>given</span> <span class=o>[</span><span class=kt>A</span><span class=o>]</span><span class=k>:</span> <span class=kt>Applicative</span><span class=o>[[</span><span class=kt>B</span><span class=o>]</span> <span class=k>=&gt;</span><span class=kt>&gt;</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span><span class=o>]]</span> <span class=k>with</span>
  <span class=k>def</span> <span class=n>pure</span><span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>x</span><span class=k>:</span> <span class=kt>B</span><span class=o>)</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Right</span><span class=o>(</span><span class=n>x</span><span class=o>)</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>B</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>ap</span><span class=o>[</span><span class=kt>C</span><span class=o>](</span><span class=n>ff</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>B</span> <span class=k>=&gt;</span> <span class=kt>C</span><span class=o>])</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>C</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>ff</span> <span class=k>match</span> 
        <span class=k>case</span> <span class=nc>Right</span><span class=o>(</span><span class=n>f</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>fa</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>f</span><span class=o>)</span>
        <span class=k>case</span> <span class=nc>Left</span><span class=o>(</span><span class=n>l</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=nc>Left</span><span class=o>(</span><span class=n>l</span><span class=o>)</span>
</code></pre></div><p>And our <code>Traverse</code> instances for <code>Identity</code> and <code>Option</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>given</span> <span class=nc>Traverse</span><span class=o>[</span><span class=kt>Identity</span><span class=o>]</span> <span class=k>with</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Identity</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>traverse</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>B</span><span class=o>])</span><span class=k>:</span> <span class=kt>G</span><span class=o>[</span><span class=kt>Identity</span><span class=o>[</span><span class=kt>B</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>f</span><span class=o>(</span><span class=n>fa</span><span class=o>)</span>

<span class=n>given</span> <span class=nc>Traverse</span><span class=o>[</span><span class=kt>Option</span><span class=o>]</span> <span class=k>with</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>A</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>A</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>traverse</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>B</span><span class=o>](</span><span class=n>f</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>B</span><span class=o>])</span><span class=k>:</span> <span class=kt>G</span><span class=o>[</span><span class=kt>Option</span><span class=o>[</span><span class=kt>B</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>fa</span> <span class=k>match</span> 
        <span class=k>case</span> <span class=nc>Some</span><span class=o>(</span><span class=n>a</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>summon</span><span class=o>[</span><span class=kt>Applicative</span><span class=o>[</span><span class=kt>G</span><span class=o>]].</span><span class=n>map</span><span class=o>(</span><span class=n>f</span><span class=o>(</span><span class=n>a</span><span class=o>))(</span><span class=nc>Some</span><span class=o>(</span><span class=k>_</span><span class=o>))</span>
        <span class=k>case</span> <span class=nc>None</span> <span class=k>=&gt;</span> <span class=n>summon</span><span class=o>[</span><span class=kt>Applicative</span><span class=o>[</span><span class=kt>G</span><span class=o>]].</span><span class=n>pure</span><span class=o>(</span><span class=nc>None</span><span class=o>)</span>
</code></pre></div><h2 id=do-it-all-over-again>Do it all over again</h2><p>To recap, we have redefined our class representing a person to use a higher-kinded type <code>F[_]</code>. This gave us the ability to reuse our data class to represent one with optional fields, streamable fields and let us define a set of validations for each field. We then created a helpful function to return our validated person or the set of errors if any were found.</p><p>If we had to start do the process again with another case class, we would find ourselves writing the same boilerplate to validate each field of the class and then sequencing and combining all the fields. Let&rsquo;s see if we can remove some of that boilerplate.</p><p>We previously discussed the <code>Applicative</code> type class which gives us the <code>map2</code> method:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>map2</span><span class=o>[</span><span class=kt>B</span>, <span class=kt>C</span><span class=o>](</span><span class=n>fa</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>A</span><span class=o>])(</span><span class=n>fb</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>B</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=o>(</span><span class=kt>A</span><span class=o>,</span> <span class=kt>B</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>C</span><span class=o>)</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>C</span><span class=o>]</span>
</code></pre></div><p>If we squint a little, we could see that our person object could map into <code>fa</code> and validation object into <code>fb</code> then the function <code>f</code> would somehow map over each field and run the validation across the corresponding value from the person object, ultimately returning a new validated person object.</p><p>Using the <code>Applicative</code> type class directly is not possible though since the type signature of <code>PersonF[F[_]]</code> does not quite match the required <code>F[A]</code>. We need to go one level higher which is usually denoted with a <code>K</code> suffix on the type classes:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>FunctorK</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]]</span><span class=nc>:</span>
  <span class=n>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>mapK</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]</span>

<span class=k>trait</span> <span class=nc>ApplyK</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]]</span> <span class=nc>extends</span> <span class=nc>FunctorK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span><span class=k>:</span>
  <span class=kt>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>map2K</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>H</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>v</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=o>(</span><span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>H</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>H</span><span class=o>]</span>
    <span class=k>def</span> <span class=n>mapK</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]</span> <span class=k>=</span> 
      <span class=n>u</span><span class=o>.</span><span class=n>map2K</span><span class=o>(</span><span class=n>u</span><span class=o>)([</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>t</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=k>_:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>t</span><span class=o>))</span>
</code></pre></div><p>Note: we do not need the full power of <code>Applicative</code> with <code>pure</code>. Instead, we need only <code>map2</code> coming from <code>Apply</code> which sits between <code>Functor</code> and <code>Applicative</code> in the type class hierarchy.</p><p>The <code>mapK</code> function takes a higher-kinded data class, <code>U[_[_]]</code>, with a higher-kinded type, <code>F[_]</code>, and a polymorphic function that can convert our <code>F[T]</code>s into <code>G[T]</code>s for any type <code>T</code>. An example function could be <code>[T] => (t: Identity[T]) => Some(t)</code> which would wrap all the fields of a data class in a <code>Some</code>. The <code>map2K</code> function is similar but takes an additional data class with a different higher-kinded type and thus the polymorphic function takes an additional argument. If we can derive <code>ApplyK</code> for our case classes we will be on the way to our goal of cutting down the boilerplate.</p><p>We can leverage the fact case classes are products in Scala to derive <code>ApplyK</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>import</span> <span class=nn>scala.compiletime.summonFrom</span>
<span class=k>import</span> <span class=nn>scala.deriving.Mirror</span>

<span class=n>inline</span> <span class=k>def</span> <span class=n>deriveApplyKForCaseClass</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=k>&lt;:</span> <span class=kt>Product</span><span class=o>]</span><span class=k>:</span> <span class=kt>ApplyK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=k>=</span> 
  <span class=k>new</span> <span class=nc>ApplyK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=o>{</span>
    <span class=n>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
      <span class=k>def</span> <span class=n>map2K</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>H</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>v</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=o>(</span><span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>H</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>H</span><span class=o>]</span> <span class=k>=</span> <span class=n>summonFrom</span> <span class=o>{</span>
        <span class=k>case</span> <span class=n>p</span><span class=k>:</span> <span class=kt>Mirror.ProductOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=&gt;</span>
          <span class=n>p</span><span class=o>.</span><span class=n>fromProduct</span><span class=o>(</span><span class=k>new</span> <span class=nc>Product</span> <span class=o>{</span>
            <span class=k>def</span> <span class=n>canEqual</span><span class=o>(</span><span class=n>that</span><span class=k>:</span> <span class=kt>Any</span><span class=o>)</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=kc>true</span>
            <span class=k>def</span> <span class=n>productArity</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>u</span><span class=o>.</span><span class=n>productArity</span>
            <span class=k>def</span> <span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>Any</span> <span class=o>=</span>
              <span class=n>f</span><span class=o>(</span><span class=n>u</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>Any</span><span class=o>]],</span> <span class=n>v</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>Any</span><span class=o>]])</span>
          <span class=o>}).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>H</span><span class=o>]]</span>
        <span class=k>case</span> <span class=k>_</span> <span class=k>=&gt;</span> <span class=n>sys</span><span class=o>.</span><span class=n>error</span><span class=o>(</span><span class=s>&#34;cannot handle this&#34;</span><span class=o>)</span>
      <span class=o>}</span>
  <span class=o>}</span>
</code></pre></div><p>To briefly summarise <code>map2K</code>&rsquo;s implementation:</p><ul><li>we start with <code>summonFrom</code> which does an implicit search for the types in the pattern match, in this case a <code>Mirror.ProductOf[U[F]]</code>. Use of this function means we must make the function <code>inline</code></li><li><code>Mirror.ProductOf[U[F]]</code> provides type level information on our product <code>U</code>. In this case, we use it to build our case class after applying the function. There is a lot more to mirrors so if interested check out the docs</li><li><code>fromProduct</code> takes a product that can be used to build an instance of <code>U</code>. We create a new product with the same arity as the original and where the nth element is the application of the function <code>f</code> on the nth element of <code>u</code> and <code>v</code> case classes. We have to do some ugly casts but I&rsquo;m not sure if that&rsquo;s avoidable</li></ul><p>Now we can rewrite our validation function from before:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>given</span> <span class=nc>ApplyK</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>]</span> <span class=k>=</span> <span class=n>deriveApplyKForCaseClass</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>]</span>

<span class=k>def</span> <span class=n>validatePersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Functor</span><span class=o>](</span><span class=n>personF</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span> 
  <span class=n>personF</span><span class=o>.</span><span class=n>map2K</span><span class=o>(</span><span class=n>personValidations</span><span class=o>)(</span>
    <span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>value</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>validation</span><span class=k>:</span> <span class=kt>Validation</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>value</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>validation</span><span class=o>)</span>
  <span class=o>)</span>
</code></pre></div><p>Any new fields added to the <code>PersonF</code> would not require any updates to this function now. We could even make this more generic, giving us the ability to validate any case class that has an instance of <code>ApplyK</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>validateU</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span><span class=kt>:</span> <span class=kt>ApplyK</span>, <span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Functor</span><span class=o>](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>],</span> <span class=n>validations</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>Validation</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span>
  <span class=n>u</span><span class=o>.</span><span class=n>map2K</span><span class=o>(</span><span class=n>validations</span><span class=o>)(</span>
    <span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>value</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>validation</span><span class=k>:</span> <span class=kt>Validation</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>value</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>validation</span><span class=o>)</span>
  <span class=o>)</span>
</code></pre></div><p>The last step in validating our case class is to return either our original case class if all validations succeeded or return the one with the error messages otherwise. We are aiming for <code>Either[U[Validation[F]], U[F]]</code>.</p><p>Looking back at the implementation in <code>validatePersonFComplete</code>, we can see the bulk of the work is in the for comprehension where each field has the same <code>sequence</code> function applied, producing <code>Either[String, F[T]]</code> for each field type <code>T</code>, and then a new <code>PersonF</code> is constructed within the context of this for comprehension, producing an <code>Either[String, PersonF[F]]</code>. This looks like traverse: performing the same function on each item, in this case each field, producing an <code>Either</code>, that ends up wrapping the <code>PersonF</code>. Let&rsquo;s take a look at <code>TraverseK</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>TraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]]</span> <span class=nc>extends</span> <span class=nc>FunctorK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span><span class=k>:</span>
  <span class=kt>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>uf</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
    <span class=k>def</span> <span class=n>traverseK</span><span class=o>[</span><span class=kt>V</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>V</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>T</span><span class=o>]])</span><span class=k>:</span> <span class=kt>V</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]]</span>
    <span class=k>def</span> <span class=n>mapK</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]</span> <span class=k>=</span> 
      <span class=n>traverseK</span><span class=o>[</span><span class=kt>Identity</span>, <span class=kt>G</span><span class=o>]([</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>ft</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>ft</span><span class=o>))</span>
</code></pre></div><p>We will have our <code>uf</code> containing our validated <code>PersonF</code>, <code>PersonF[[T] =>> F[Either[String, T]]]</code>, and so need to define the function <code>f</code> that will return an <code>Applicative</code>. We already provided an instance of <code>Applicative</code> for <code>[T] =>> Either[A, T]</code> and so it looks like we can use that and the <code>traverseK</code> will then return <code>Either[String, PersonF[F]]</code> which is what we&rsquo;re looking for. It can be a little confusing to map the types we have to this function because the <code>F</code> in our desired returned type is actually the <code>G</code> in the function&rsquo;s context bounds and the <code>[T] =>> F[Either[String, T]]</code> is the <code>F</code>.</p><p>The <code>f</code> we will provide to this function is then <code>[T] => (x: F[Either[String, T]]) => x.sequence</code>. Given a type <code>T</code> and value <code>F[Either[String, T]]</code>, if we flip the <code>F</code> and <code>Either</code> with <code>sequence</code> we will get the type we want of <code>Either[String, F[T]]</code>.</p><p>Before going any further, let&rsquo;s see if we can derive <code>TraverseK</code> for our case class using a similar process as in <code>ApplyK</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>inline</span> <span class=k>def</span> <span class=n>deriveTraverseKForCaseClass</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=k>&lt;:</span> <span class=kt>Product</span><span class=o>]</span><span class=k>:</span> <span class=kt>TraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=k>=</span> 
  <span class=k>new</span> <span class=nc>TraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=o>{</span>
    <span class=n>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
      <span class=k>def</span> <span class=n>traverseK</span><span class=o>[</span><span class=kt>V</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>V</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>T</span><span class=o>]])</span><span class=k>:</span> <span class=kt>V</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]]</span> <span class=k>=</span> <span class=n>summonFrom</span> <span class=o>{</span>
        <span class=k>case</span> <span class=n>p</span><span class=k>:</span> <span class=kt>Mirror.ProductOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=&gt;</span>
          <span class=k>val</span> <span class=n>appliedF</span> <span class=k>=</span> <span class=n>u</span><span class=o>.</span><span class=n>productIterator</span><span class=o>.</span><span class=n>toList</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>t</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>Any</span><span class=o>]]))</span>
          <span class=k>val</span> <span class=n>vTuple</span><span class=k>:</span> <span class=kt>V</span><span class=o>[</span><span class=kt>Tuple</span><span class=o>]</span> <span class=k>=</span> <span class=n>appliedF</span><span class=o>.</span><span class=n>foldRight</span><span class=o>(</span><span class=n>summon</span><span class=o>[</span><span class=kt>Applicative</span><span class=o>[</span><span class=kt>V</span><span class=o>]].</span><span class=n>pure</span><span class=o>(</span><span class=nc>EmptyTuple</span><span class=o>))</span> <span class=o>{</span> <span class=o>(</span><span class=n>vgs</span><span class=o>,</span> <span class=n>x</span><span class=o>)</span> <span class=k>=&gt;</span>
            <span class=n>x</span><span class=o>.</span><span class=n>map2</span><span class=o>(</span><span class=n>vgs</span><span class=o>)((</span><span class=n>tuple</span><span class=o>,</span> <span class=n>a</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>a</span> <span class=o>*:</span> <span class=n>tuple</span><span class=o>)</span> <span class=o>)</span>
          <span class=o>}</span>

          <span class=n>vTuple</span><span class=o>.</span><span class=n>map</span> <span class=o>{</span> <span class=n>tuple</span> <span class=k>=&gt;</span>
            <span class=n>p</span><span class=o>.</span><span class=n>fromProduct</span><span class=o>(</span><span class=k>new</span> <span class=nc>Product</span> <span class=o>{</span>
              <span class=k>def</span> <span class=n>canEqual</span><span class=o>(</span><span class=n>that</span><span class=k>:</span> <span class=kt>Any</span><span class=o>)</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=kc>true</span>
              <span class=k>def</span> <span class=n>productArity</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>tuple</span><span class=o>.</span><span class=n>productArity</span>
              <span class=k>def</span> <span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>Any</span> <span class=o>=</span>
                <span class=n>tuple</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>)</span>
            <span class=o>}).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]]</span>
          <span class=o>}</span>
      <span class=o>}</span>
  <span class=o>}</span>
</code></pre></div><p>As before, we require <code>U</code> to be a product so we can summon the mirror. The first thing we do after summoning is apply the function <code>f</code> to each of the fields producing a list of <code>V[G[Any]]</code>. Since <code>V</code> is applicative, we can build a tuple within the context of <code>V</code> by making use of <code>map2</code> whilst folding over the list. This results in <code>V[(G[Any], G[Any], G[Any], ..., G[Any])]</code> which we can then <code>map</code> into and create our case class with the mirror.</p><p>Rewriting <code>validatePersonFComplete</code> will then be:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>given</span> <span class=nc>TraverseK</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>]</span> <span class=k>=</span> <span class=n>deriveTraverseKForCaseClass</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>]</span>

<span class=k>def</span> <span class=n>validatePersonFComplete</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Traverse</span><span class=o>](</span><span class=n>personF</span><span class=k>:</span> <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>PersonF</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span>, <span class=kt>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span> 
  <span class=k>val</span> <span class=n>v</span> <span class=k>=</span> <span class=n>validatePersonF</span><span class=o>(</span><span class=n>personF</span><span class=o>)</span>
  <span class=k>val</span> <span class=n>e</span> <span class=k>=</span> <span class=n>v</span><span class=o>.</span><span class=n>traverseK</span><span class=o>([</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>x</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Either</span><span class=o>[</span><span class=kt>String</span>, <span class=kt>T</span><span class=o>]])</span> <span class=k>=&gt;</span> <span class=n>x</span><span class=o>.</span><span class=n>sequence</span><span class=o>)</span>
  <span class=n>e</span><span class=o>.</span><span class=n>fold</span><span class=o>(</span><span class=k>_</span> <span class=k>=&gt;</span> <span class=nc>Left</span><span class=o>(</span><span class=n>v</span><span class=o>),</span> <span class=nc>Right</span><span class=o>(</span><span class=k>_</span><span class=o>))</span>
</code></pre></div><p>As before with <code>validateU</code>, we can make this more generic:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>def</span> <span class=n>validateUComplete</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span><span class=kt>:</span> <span class=kt>TraverseK:</span> <span class=kt>ApplyK</span>, <span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Traverse</span><span class=o>](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>],</span> <span class=n>validations</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>Validation</span><span class=o>])</span><span class=k>:</span> <span class=kt>Either</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>Validated</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span>, <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=</span>
  <span class=k>val</span> <span class=n>v</span> <span class=k>=</span> <span class=n>validateU</span><span class=o>(</span><span class=n>u</span><span class=o>,</span> <span class=n>validations</span><span class=o>)</span>
  <span class=k>val</span> <span class=n>e</span> <span class=k>=</span> <span class=n>v</span><span class=o>.</span><span class=n>traverseK</span><span class=o>([</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>x</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Either</span><span class=o>[</span><span class=kt>String</span>, <span class=kt>T</span><span class=o>]])</span> <span class=k>=&gt;</span> <span class=n>x</span><span class=o>.</span><span class=n>sequence</span><span class=o>)</span>
  <span class=n>e</span><span class=o>.</span><span class=n>fold</span><span class=o>(</span><span class=k>_</span> <span class=k>=&gt;</span> <span class=nc>Left</span><span class=o>(</span><span class=n>v</span><span class=o>),</span> <span class=nc>Right</span><span class=o>(</span><span class=k>_</span><span class=o>))</span>
</code></pre></div><p>And there we have it, we can validate any flat higher-kinded data given the higher-kinded type is traversable.</p><h3 id=derivation>Derivation</h3><p>One final useful thing we can do is implement <a href=https://dotty.epfl.ch/docs/reference/contextual/derivation.html>type class derivation</a>. Then, when we define our HKD case class, we can write something like <code>A[F[_]](a: F[Int]) derives ApplyK</code> to automatically have an <code>ApplyK</code> instance for <code>A</code>.</p><p>Since we want to derive both <code>ApplyK</code> and <code>TraverseK</code>, and they both inherit <code>mapK</code> from <code>FunctorK</code>, we will need to define a new type class that is the union of them both:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>trait</span> <span class=nc>ApplyTraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]]</span> <span class=nc>extends</span> <span class=nc>ApplyK</span><span class=o>[</span><span class=kt>U</span><span class=o>],</span> <span class=nc>TraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span><span class=k>:</span>
  <span class=kt>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>mapK</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]</span> <span class=k>=</span> 
      <span class=n>u</span><span class=o>.</span><span class=n>traverseK</span><span class=o>[</span><span class=kt>Identity</span>, <span class=kt>G</span><span class=o>]([</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>ft</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>ft</span><span class=o>))</span>
</code></pre></div><p>Then we define a companion object with the method <code>derived</code> which copies the <code>traverseK</code> and <code>map2K</code> implementations from before:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>object</span> <span class=nc>ApplyTraverseK</span><span class=k>:</span>
  <span class=kt>inline</span> <span class=kt>def</span> <span class=kt>derived</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=k>_</span><span class=o>[</span><span class=k>_</span><span class=o>]]</span> <span class=k>&lt;:</span> <span class=kt>Product</span><span class=o>]</span><span class=k>:</span> <span class=kt>ApplyTraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>ApplyTraverseK</span><span class=o>[</span><span class=kt>U</span><span class=o>]</span> <span class=o>{</span>
    <span class=n>extension</span> <span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>u</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>])</span>
      <span class=k>def</span> <span class=n>traverseK</span><span class=o>[</span><span class=kt>V</span><span class=o>[</span><span class=k>_</span><span class=o>]</span><span class=kt>:</span> <span class=kt>Applicative</span>, <span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=k>=&gt;</span> <span class=n>V</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>T</span><span class=o>]])</span><span class=k>:</span> <span class=kt>V</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]]</span> <span class=k>=</span> <span class=n>summonFrom</span> <span class=o>{</span>
        <span class=k>case</span> <span class=n>p</span><span class=k>:</span> <span class=kt>Mirror.ProductOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=&gt;</span>
          <span class=k>val</span> <span class=n>appliedF</span> <span class=k>=</span> <span class=n>u</span><span class=o>.</span><span class=n>productIterator</span><span class=o>.</span><span class=n>toList</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>t</span> <span class=k>=&gt;</span> <span class=n>f</span><span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>Any</span><span class=o>]]))</span>
          <span class=k>val</span> <span class=n>vTuple</span><span class=k>:</span> <span class=kt>V</span><span class=o>[</span><span class=kt>Tuple</span><span class=o>]</span> <span class=k>=</span> <span class=n>appliedF</span><span class=o>.</span><span class=n>foldRight</span><span class=o>(</span><span class=n>summon</span><span class=o>[</span><span class=kt>Applicative</span><span class=o>[</span><span class=kt>V</span><span class=o>]].</span><span class=n>pure</span><span class=o>(</span><span class=nc>EmptyTuple</span><span class=o>))</span> <span class=o>{</span> <span class=o>(</span><span class=n>vgs</span><span class=o>,</span> <span class=n>x</span><span class=o>)</span> <span class=k>=&gt;</span>
            <span class=n>x</span><span class=o>.</span><span class=n>map2</span><span class=o>(</span><span class=n>vgs</span><span class=o>)((</span><span class=n>tuple</span><span class=o>,</span> <span class=n>a</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=o>(</span><span class=n>a</span> <span class=o>*:</span> <span class=n>tuple</span><span class=o>)</span> <span class=o>)</span>
          <span class=o>}</span>
          <span class=n>vTuple</span><span class=o>.</span><span class=n>map</span> <span class=o>{</span> <span class=n>tuple</span> <span class=k>=&gt;</span>
            <span class=n>p</span><span class=o>.</span><span class=n>fromProduct</span><span class=o>(</span><span class=k>new</span> <span class=nc>Product</span> <span class=o>{</span>
              <span class=k>def</span> <span class=n>canEqual</span><span class=o>(</span><span class=n>that</span><span class=k>:</span> <span class=kt>Any</span><span class=o>)</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=kc>true</span>
              <span class=k>def</span> <span class=n>productArity</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>tuple</span><span class=o>.</span><span class=n>productArity</span>
              <span class=k>def</span> <span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>Any</span> <span class=o>=</span>
                <span class=n>tuple</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>)</span>
            <span class=o>}).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>]]</span>
          <span class=o>}</span>
        <span class=k>case</span> <span class=k>_</span> <span class=k>=&gt;</span> <span class=n>sys</span><span class=o>.</span><span class=n>error</span><span class=o>(</span><span class=s>&#34;cannot handle&#34;</span><span class=o>)</span>
      <span class=o>}</span>
      <span class=k>def</span> <span class=n>map2K</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=k>_</span><span class=o>]</span>, <span class=kt>H</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span><span class=n>v</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>G</span><span class=o>])(</span><span class=n>f</span><span class=k>:</span> <span class=err>[</span><span class=kt>T</span><span class=err>]</span> <span class=o>=&gt;</span> <span class=o>(</span><span class=n>F</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>G</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=n>H</span><span class=o>[</span><span class=kt>T</span><span class=o>])</span><span class=k>:</span> <span class=kt>U</span><span class=o>[</span><span class=kt>H</span><span class=o>]</span> <span class=k>=</span>
        <span class=n>summonFrom</span> <span class=o>{</span>
          <span class=k>case</span> <span class=n>p</span><span class=k>:</span> <span class=kt>Mirror.ProductOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>F</span><span class=o>]]</span> <span class=k>=&gt;</span>
            <span class=n>p</span><span class=o>.</span><span class=n>fromProduct</span><span class=o>(</span><span class=k>new</span> <span class=nc>Product</span> <span class=o>{</span>
              <span class=k>def</span> <span class=n>canEqual</span><span class=o>(</span><span class=n>that</span><span class=k>:</span> <span class=kt>Any</span><span class=o>)</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=kc>true</span>
              <span class=k>def</span> <span class=n>productArity</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>u</span><span class=o>.</span><span class=n>productArity</span>
              <span class=k>def</span> <span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>Any</span> <span class=o>=</span>
                <span class=n>f</span><span class=o>(</span><span class=n>u</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=kt>Any</span><span class=o>]],</span> <span class=n>v</span><span class=o>.</span><span class=n>productElement</span><span class=o>(</span><span class=n>n</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>G</span><span class=o>[</span><span class=kt>Any</span><span class=o>]])</span>
            <span class=o>}).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>U</span><span class=o>[</span><span class=kt>H</span><span class=o>]]</span>
          <span class=k>case</span> <span class=k>_</span> <span class=k>=&gt;</span> <span class=n>sys</span><span class=o>.</span><span class=n>error</span><span class=o>(</span><span class=s>&#34;cannot handle&#34;</span><span class=o>)</span>
        <span class=o>}</span>
  <span class=o>}</span>
</code></pre></div><p>And now, we can go back to our <code>PersonF</code> case class and append <code>derives ApplyTraverseK</code>:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=k>case</span> <span class=k>class</span> <span class=nc>PersonF</span><span class=o>[</span><span class=kt>F</span><span class=o>[</span><span class=k>_</span><span class=o>]](</span>
    <span class=n>name</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>age</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Int</span><span class=o>],</span> 
    <span class=n>postcode</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> 
    <span class=n>nickname</span><span class=k>:</span> <span class=kt>F</span><span class=o>[</span><span class=kt>Option</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span>
<span class=o>)</span> <span class=n>derives</span> <span class=nc>ApplyTraverseK</span>
</code></pre></div><p>An instance of <code>PersonF</code> will have the <code>mapK</code>, <code>map2K</code> and <code>traverseK</code> methods available to it now.</p><h2 id=summary>Summary</h2><p>That was a pretty long journey but I wanted to capture the whole process of going from our <code>Person</code> case class definition to providing a generic way of validating HKD and deriving the required type classes. All of the code snippets, with some examples that pass and fail validations, are available on <a href=https://github.com/charlibot/hkd>Github</a>. Some of what is here can be found in existing libraries and need not be reimplemented. In particular, <a href=https://github.com/typelevel/cats>cats</a> can provide our non-K type classes (<code>Functor</code>, <code>Applicative</code>, <code>Traverse</code>) and instances for <code>Option</code>, <code>Either</code> and <code>Identity</code> (in Cats just <code>Id</code>).</p><p><a href="https://www.youtube.com/watch?v=k8IgRayL4vo">Oleg Nizhnikov - HKD: stem cells for data</a> was the spark that started this write-up. The <a href=https://github.com/Odomontois/data-lab>associated source</a> also greatly helped. There, he provides derivations for <code>RepresentableK</code> for case classes amongst other things which I did not need here. I also looked at the following which helped wrap my head around this topic:</p><ul><li><a href=https://github.com/Katrix/perspective>Katrix&rsquo;s perspective library</a></li><li><a href="https://www.youtube.com/watch?v=sIqZEmnFer8">Chris Penner&rsquo;s talk</a></li><li>Michael Thomas' two repos:<ul><li><a href=https://github.com/Michaelt293/higher-kinded-data>Higher-kinded data</a></li><li><a href=https://github.com/Michaelt293/higher-kinded-aggregations>Higher-kinded aggregations</a></li></ul></li><li><a href=https://blog.philipp-martini.de/blog/magic-mirror-scala3/>Philipp Martini&rsquo;s blog post</a> was also helpful to understand the mirror usage in the deriving functions.</li></ul><p>Taking a glimpse at any of those links shows I&rsquo;ve barely scratched the surface here. Although for now, I think we can leave it there and call it a day.</p><p>Thanks for reading!</p></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/fp>#fp</a>
<a class=tag href=/tags/scala3>#scala3</a></div></div><footer class=footer-mobile><div class=social-icons><a class=social-icon href=https://github.com/charlibot target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://charlibot.github.io/js/main.min.c1aee25a817e9beb1f9c4afd9d62311227a7f5e46720e404dc1dda97281f47f2.js integrity="sha256-wa7iWoF+m+sfnEr9nWIxEien9eRnIOQE3B3alygfR/I=" crossorigin=anonymous></script></footer></body></html>